# Continuous Monitoring: Power Automate

## Summary

The goal of this article is to describe how to implement a monitoring strategy for both Power Automate and the Logic App services. We will explore how to monitor maker modifications such as creating and updating Power Automate flows and connectors. After than we will dive deep into triggers and actions and how to extract information from individual flow runs. We will then look into how to add Application Insights into Power Automate. From there we move into Azure Logic Applications and how to monitor with Azure Monitor, previously known as Log Analytics.

## Overview of Power Automate

Power Automate, previously known as Microsoft Flow, is a citizen developer platform allowing for connecting and integration dispersed systems. Featuring a graphical user interface and features such as Power Automate Checker, the Power Automate platform is designed from the ground up as a all up solution for citizen developers. The platform allows makers to design and build My Flows and share with their team members. Flows can range from many different use cases, from scheduled CRON like jobs to webhooks and button presses kicking off maker crafted workflows. Sending emails and notifications, responding to data changes can all be done without writing a single line of code!

### Power Automate and the Power Platform

Power Automate is part of and integral to the Power Platform suite. It can be used to connect and perform actions across PowerApps and Power Virtual Agents. For PowerApps Model Driven Apps, Power Automate flows are native to the platform and provide citizen developers and administrators to not only reference Power Automate from the platform UI but to migrate and deploy customizations via solutions.

Creating what is called solution aware Power Automate flows is key to not only continuous delivery but also continuous monitoring. Solution aware Power Automate flows leverage the Common Data Service (CDS) and with that can provide valuable insights. The PowerApps Portal can be leveraged to show analytics while the PowerShell cmdlets can show runs across an environment and not scoped to an individual user.

## Monitoring Power Automate Runs

As detailed in the document "PowerApps Admin White Paper": https://aka.ms/powerappsadminwhitepaper there are two ways currently to monitor Power Automate usage, the PowerApps Portal and programmatically with PowerShell. Evaluating need you may leverage one or both to review usage at a high level down to individual runs.

### The PowerApps Portal

The PowerApps Admin Portal offers administrators the ability to review Analytics for Power Apps, Power Automate and the Common Data Service. For Power Automate, analytics include Runs, Usage, Created Flows, Flows with Errors, Shared Flows and Connectors that happened within a user defined interval. This data is refreshed periodically throughout the day and the refresh date can be found within the analytics pane.

Connectors analytics include how many connectors were used by a flow run, how many calls were made to a connector, connector usage across flows and flows that use connectors.

Errors show error types and errors across flows. 

<img src="https://raw.githubusercontent.com/wiki/aliyoussefi/D365-Monitoring/Artifacts/PowerAutomate/PowerPlatform Admin Portal - Usage Tab.JPG" style="zoom:50%;" />

<img src="https://raw.githubusercontent.com/wiki/aliyoussefi/D365-Monitoring/Artifacts/PowerAutomate/PowerAutomateAnalytics-Connectors-Charts.JPG" style="zoom:50%;" />

### The Power Automate PowerShell Cmdlets

**<u>Get-FlowEnvironment</u>** - This allows an administrator to get an environment or list of environments based on specified criteria such as the default environment, environment name or a filter. This will return the environment name, the display name and other properties which can be used downstream for other cmdlets.

**<u>Get-AdminFlow</u>** - Using the environment an administrator can search for existing flows. This will prove helpful to get the flow name and definition of the flow and other properties.

<img src="https://raw.githubusercontent.com/wiki/aliyoussefi/D365-Monitoring/Artifacts/PowerAutomate/PowerAutomate-PowerShell-Get-AdminFlow.JPG" style="zoom:50%;" />

**<u>Get-FlowRun</u>** - This can show the individual run of a specific flow including the status, the start and end times, a correlationId and trigger information.

<img src="https://raw.githubusercontent.com/wiki/aliyoussefi/D365-Monitoring/Artifacts/PowerAutomate/PowerAutomate-PowerShell-Get-Flow.JPG" style="zoom:50%;" />

As shown in the picture above, a failed status can be shown along with the message. In this image we see the message within the error object in PowerShell. In the following sections I'll begin to cover how to capture identifiers. These identifiers coupled with the PowerShell cmdlets shown can help track individual flow runs.

### The Common Data Service Web API and Power Automate

NOTE: This feature is for flows included in solutions. As stated in the article, going forward [all flows will be stored in the Common Data Service and leverage the API](https://docs.microsoft.com/en-us/power-automate/web-api). This doesn't mean they are necessarily in a managed solution by default and I'd recommend working with solutions when creating flows. 

The Common Data Service API allows an administrator to [list flows](https://docs.microsoft.com/en-us/power-automate/web-api#list-flows), [update flows](https://docs.microsoft.com/en-us/power-automate/web-api#update-a-flow), [see what flows are shared with others](https://docs.microsoft.com/en-us/power-automate/web-api#get-all-users-with-whom-a-flow-is-shared) and [import](https://docs.microsoft.com/en-us/power-automate/web-api#import-flows) and [export](https://docs.microsoft.com/en-us/power-automate/web-api#export-flows) flows with solutions. Use this as you would the Dynamics 365 API meaning utilize the security model for authentication and authorization and standard operations for CRUD and Import/Export actions.

When viewing workflow records using the Common Data Service API, the "*workflowidunique*", "*name*" and "*clientdata*" fields contain information that can be found on the Power Automate flow. <u>Its important to point out that the *workflowidunique* is not static and can change as flows are moved across environments.</u>

Here is an OData example that selects these three fields:

```
https://org542036ad.crm.dynamics.com/api/data/v9.1/workflows(<CDS-workflowId>)?$select=workflowidunique,name,clientdata
```

<img src="https://raw.githubusercontent.com/wiki/aliyoussefi/D365-Monitoring/Artifacts/PowerAutomate/CDS-WorkflowIdUnique-workflow-name.JPG" style="zoom:50%;" />

As the image above shows, the *workflowidunique* field from the CDS API matches up with the "*x-ms-workflowname*" output header from the child workflow.

## Capturing Flow Run Information

### Triggers

Triggers are used to fire off a Power Automate flow. They can be triggers that are invoked, triggers that reoccur and triggers that poll for a specific event. Triggers can be configured to use conditions which can help control if a Power Automate flow is going to run or not. When designing the expression keep in mind it must evaluate to true of false.

The following image shows a trigger condition that will keep the flow from firing unless the *correlationid* and *body* fields are present in the triggerBody.

<img src="https://raw.githubusercontent.com/wiki/aliyoussefi/D365-Monitoring/Artifacts/PowerAutomate/PowerAutomate-Triggers-HTTP.JPG" style="zoom:50%;" />

Triggers can contain inputs, outputs, timings, keywords and statuses. Depending on the type of trigger you may or may not receive specific properties. Keep this in mind when attempting to read from the trigger object as some, such as recurrence, will not contain inputs and outputs.

The below image is the trigger for a Recurrence:

<img src="https://raw.githubusercontent.com/wiki/aliyoussefi/D365-Monitoring/Artifacts/PowerAutomate/Trigger-Object-Recurrance-JSON.JPG" style="zoom:50%;" />

The below image is the trigger information for the Common Data Service:

<img src="https://raw.githubusercontent.com/wiki/aliyoussefi/D365-Monitoring/Artifacts/PowerAutomate/Trigger-Object-JSON.JPG" style="zoom:50%;" />

Notice the host contains the specific operation id, but more important is the dataset parameter which shows which environment the trigger is listening to. In this case this represents the "**(current)**" environment. Additionally the correlation and client request identifiers are shown which can help track and troubleshoot flows.

### Flow Object

The Power Automate run information can be found in the *workflow* method which contains information about the flow, the environment, and the specific run. 

<img src="https://raw.githubusercontent.com/wiki/aliyoussefi/D365-Monitoring/Artifacts/PowerAutomate/Workflow-ObjectOverview.JPG" style="zoom:50%;" />

To find out more about the specific run, you can cast the *workflow().run* object as a variable and view the properties. Run properties include the id, the name, and the type. This information can be correlated to the *ClientTrackingId* found in the **Get-FlowRun** cmdlet above. Additionally, the flow is described in the tags object. The tags object contains the display name, the environment it belongs to, if its part of the common data service (solution aware) and the logic app name.

<img src="https://raw.githubusercontent.com/wiki/aliyoussefi/D365-Monitoring/Artifacts/PowerAutomate/Workflow-Run-Overview.JPG" style="zoom:50%;" />

## Capturing Connection and Action Responses

One of Power Automate's greatest capabilities is the ability to connect systems in a no code approach allowing makers from all sorts of background to develop integrations. Most of these integration connections perform some sort of action to gather and manipulate data, invoke a process, and return some value. Each of these actions includes some output which can be read and stored for further examination <u>natively</u> within a Power Automate flow.

In these action outputs, specifically ones that perform an external connection, lies headers, some status code and body. These objects can be read by using the expression outputs('<name of the action>'). Take for example the below image:

<img src="https://raw.githubusercontent.com/wiki/aliyoussefi/D365-Monitoring/Artifacts/PowerAutomate/Outputs-CDS-Update_a_record.JPG" style="zoom:50%;" />

The value of the variable is an expression "@outputs('Update_a_record')". You can see the top action is called "Update a record" and is a CDS type of action. By setting this expression we can now read the following:

<img src="https://raw.githubusercontent.com/wiki/aliyoussefi/D365-Monitoring/Artifacts/PowerAutomate/Trigger-vs-Action-CDS-Headers.JPG" style="zoom:50%;" />

The image above shows a comparison of the Common Data Service Trigger against the Action. Notice how the action includes the status code as opposed to the status of succeeded that the trigger produced. This status code along with the body is essential when dealing with failed or incomplete integrations.

#### Handling and Capturing Errors in Actions

Typically Power Automate flows will fail out if an issue occurs. Manually we can review these failures in the Power Automate Portal or with PowerShell. However inside the Power Automate flow we have the ability to track the statusCode. Along with the Configure Run After setting we can conditionally capture any error messages and report or store for analysis.

<img src="https://raw.githubusercontent.com/wiki/aliyoussefi/D365-Monitoring/Artifacts/PowerAutomate/MockError-HTTP-ConfigureRunAfter.JPG" />

The Configure Run After setting allows the flow to continue if an error occurs. This can be used in conjunction with the below image showing a conditional based on status of the output body:

<img src="https://raw.githubusercontent.com/wiki/aliyoussefi/D365-Monitoring/Artifacts/PowerAutomate/MockError-HTTP-Designer-Conditional.JPG" />

Integration actions can be simulate responses which can be helpful to troubleshoot without invoking a live system or for designing error handling.

<img src="https://raw.githubusercontent.com/wiki/aliyoussefi/D365-Monitoring/Artifacts/PowerAutomate/MockError-DevOps-StaticResult.JPG" />

#### Capturing Power Apps Canvas App Information with Power Automate

An issue I ran into when working with Power Apps Canvas Apps is how to capture the Session Id that users have access to when playing the app. As detailed in the Continuous Monitoring: Canvas App article, we have the native capability to send events to Azure Application Insights. At the time of this writing, the session identifier presented in the entries did not match up to the session id in the player.

Using the techniques shown in this article I was able to capture the session id from the headers of the PowerApps trigger. The image below shows the correlation between the Session Id in the Canvas App Player to the "x-ms-client-session-id" in the PowerApps trigger.

<img src="https://raw.githubusercontent.com/wiki/aliyoussefi/D365-Monitoring/Artifacts/PowerAutomate/PowerApps-Trigger-CanvasApp-SessionId-Correlation.JPG" style="zoom:50%;" />

Adding or using the Session Id in a Canvas App:

<img src="https://raw.githubusercontent.com/wiki/aliyoussefi/D365-Monitoring/Artifacts/PowerAutomate/PowerApps-Trigger-CanvasApp-SessionId-Correlation-In-PowerApps.JPG" style="zoom:50%;" />

That said, I have not seen this documented and would recommend implementing a custom identifier approach in case this gets removed. 

## Adding Application Performance Monitoring to Power Automate

### Adding a custom Correlation Id

<img src="https://raw.githubusercontent.com/wiki/aliyoussefi/D365-Monitoring/Artifacts/PowerAutomate/PowerAutomate-Triggers-HTTP.JPG" style="zoom:50%;" />

The Custom Tracking Id, part of the trigger, allows for the static of dynamic input of an identifier that can be passed in or set from the trigger and added to the response. This identifier can also be used across child flows to represent the calling or parent flow.

<insert tracking id image>

<img src="https://raw.githubusercontent.com/wiki/aliyoussefi/D365-Monitoring/Artifacts/PowerAutomate/Trigger-Object-Recurrance-JSON.JPG" style="zoom:50%;" />

### Utilizing a system provided Correlation Id

Power Automate also includes its own correlation identifiers as referenced in the Get-FlowRun cmdlet as part of the *ClientTrackingId*. This identifier can be obtained in the flow itself by use of the outputs object. Consider using this or a custom tracking identifier when working with external integrations to assist with application and workload monitoring. By implementing this early, the beginnings of an application map can appear when working with Azure Application Insights.

<insert app map image>

<img src="https://raw.githubusercontent.com/wiki/aliyoussefi/D365-Monitoring/Artifacts/PowerAutomate/Trigger-Object-Recurrance-JSON.JPG" style="zoom:50%;" />

### Tracked Properties

Tracked Properties are part of every action within Power Automate. They provide the ability to add properties behind the scenes that can be referenced as part of the specific action.

https://powerusers.microsoft.com/t5/General-Power-Automate/Approval-Flow-Tracked-Properties/td-p/237387

http://johnliu.net/blog/2018/10/hiding-your-microsoft-flow-valuables-i-mean-variables-out-of-sight

### Sending an event to Application Insights

Azure Application Insights, as mentioned in previous articles, is an application performance monitoring platform. Power Automate, at the time of this writing, does not have a native integration or feature to push events to Application Insights. However, following the technique described in the article Continuous Monitoring: Dynamics 365 Plugin section we can construct and send virtually any message we want to Application Insights. This will allow for tracking not only errors but performance of each individual action within a Power Automate flow if desired.

To achieve this we will send a POST message to the Application Insights endpoint with the definition of the specific event we want to capture. This endpoint can accept one or multiple messages so it can be used at the end of a Power Automate flow run or really anywhere.

<insert PowerApps triggered AppInsights image>

<img src="https://raw.githubusercontent.com/wiki/aliyoussefi/D365-Monitoring/Artifacts/PowerAutomate/Trigger-Object-Recurrance-JSON.JPG" style="zoom:50%;" />

The trigger I'm using here is the PowerApps trigger which allow for use of this flow as a child flow. Remember to use this flow in this manner the flow must be solution aware.

<insert AppInsights Post from Flow image>

<img src="https://raw.githubusercontent.com/wiki/aliyoussefi/D365-Monitoring/Artifacts/PowerAutomate/Trigger-Object-Recurrance-JSON.JPG" style="zoom:50%;" />

Now the image above shows how to take the contract for a specific table and inject variables which will show up in Application Insights. In this example I'm only using the customEvents table but this can easily be extended for all tables within Application Insights.

Most tables in Application Insights include a customDimensions and customMeasurements property bag which I would recommend passing contextual data from the flow. All tables include user and session data points which can be used to help facilitate out of the box capabilities in Application Insights such as the application map mentioned above.

<insert AppInsights table image>

<img src="https://raw.githubusercontent.com/wiki/aliyoussefi/D365-Monitoring/Artifacts/PowerAutomate/Trigger-Object-Recurrance-JSON.JPG" style="zoom:50%;" />